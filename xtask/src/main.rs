use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[command(name = "xtask", about = "SignalDB code generation tooling")]
struct Cli {
    #[command(subcommand)]
    command: Command,
}

#[derive(Subcommand)]
enum Command {
    /// Generate code from the OpenAPI spec
    Generate,
    /// Check that generated code is up-to-date (for CI)
    Check,
}

fn main() -> Result<()> {
    let cli = Cli::parse();
    match cli.command {
        Command::Generate => generate(false),
        Command::Check => generate(true),
    }
}

fn project_root() -> PathBuf {
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .expect("xtask must be inside the workspace")
        .to_path_buf()
}

fn generate(check_only: bool) -> Result<()> {
    let root = project_root();
    let spec_yaml = std::fs::read_to_string(root.join("api/admin-api.yaml"))
        .context("reading api/admin-api.yaml")?;

    // Parse YAML â†’ JSON Value (works because serde_json::Value implements Deserialize)
    let json_value: serde_json::Value =
        serde_yaml::from_str(&spec_yaml).context("parsing YAML as JSON value")?;

    // --- admin-api.json ---
    let json_pretty = serde_json::to_string_pretty(&json_value).context("serializing JSON")?;
    write_or_check(
        &root.join("api/admin-api.json"),
        &format!("{json_pretty}\n"),
        check_only,
    )?;

    // --- signaldb-api types (typify) ---
    let api_types = generate_api_types(&json_value)?;
    write_or_check(
        &root.join("src/signaldb-api/src/generated.rs"),
        &api_types,
        check_only,
    )?;

    // --- signaldb-sdk client (progenitor) ---
    let sdk_client = generate_sdk_client(&json_value)?;
    write_or_check(
        &root.join("src/signaldb-sdk/src/generated.rs"),
        &sdk_client,
        check_only,
    )?;

    if check_only {
        eprintln!("All generated files are up-to-date.");
    } else {
        eprintln!("Code generation complete.");
    }
    Ok(())
}

/// Generate Rust type definitions from the OpenAPI component schemas using typify.
fn generate_api_types(spec: &serde_json::Value) -> Result<String> {
    let schemas = spec
        .get("components")
        .and_then(|c| c.get("schemas"))
        .context("no components.schemas in spec")?
        .as_object()
        .context("components.schemas is not an object")?;

    let mut settings = typify::TypeSpaceSettings::default();
    settings
        .with_derive("Debug".to_string())
        .with_derive("Clone".to_string());

    let mut type_space = typify::TypeSpace::new(&settings);

    // Convert each OpenAPI schema to a schemars Schema.
    // Rewrite $ref paths from "#/components/schemas/X" to "#/definitions/X"
    // because typify expects JSON-Schema-style references.
    let ref_types: Vec<(String, schemars::schema::Schema)> = schemas
        .iter()
        .map(|(name, schema)| {
            let mut schema_json = schema.clone();
            rewrite_refs(&mut schema_json);
            let s: schemars::schema::Schema = serde_json::from_value(schema_json)
                .with_context(|| format!("converting schema '{name}' to schemars"))?;
            Ok((name.clone(), s))
        })
        .collect::<Result<Vec<_>>>()?;

    type_space
        .add_ref_types(ref_types)
        .context("adding ref types to TypeSpace")?;

    let tokens = type_space.to_stream();
    let ast: syn::File = syn::parse2(tokens).context("parsing typify output as syn::File")?;
    let code = prettyplease::unparse(&ast);

    let formatted = run_rustfmt(&code)?;
    Ok(format!(
        "// This file is generated by `cargo xtask generate`. Do not edit.\n\n{formatted}"
    ))
}

/// Generate a full HTTP client from the OpenAPI spec using progenitor.
fn generate_sdk_client(spec: &serde_json::Value) -> Result<String> {
    let openapi: openapiv3::OpenAPI =
        serde_json::from_value(spec.clone()).context("parsing spec as openapiv3::OpenAPI")?;

    let mut settings = progenitor::GenerationSettings::default();
    settings
        .with_interface(progenitor::InterfaceStyle::Builder)
        .with_tag(progenitor::TagStyle::Merged);

    let mut generator = progenitor::Generator::new(&settings);
    let tokens = generator
        .generate_tokens(&openapi)
        .context("progenitor generate_tokens")?;
    let ast: syn::File = syn::parse2(tokens).context("parsing progenitor output as syn::File")?;
    let code = prettyplease::unparse(&ast);

    let formatted = run_rustfmt(&code)?;
    Ok(format!(
        "// This file is generated by `cargo xtask generate`. Do not edit.\n\n{formatted}"
    ))
}

/// Rewrite `$ref` from `#/components/schemas/X` to `#/definitions/X` so that
/// typify (which uses JSON Schema conventions) can resolve cross-references.
fn rewrite_refs(value: &mut serde_json::Value) {
    match value {
        serde_json::Value::Object(map) => {
            if let Some(ref_val) = map.get_mut("$ref")
                && let Some(s) = ref_val.as_str()
                && let Some(name) = s.strip_prefix("#/components/schemas/")
            {
                *ref_val = serde_json::Value::String(format!("#/definitions/{name}"));
            }
            for v in map.values_mut() {
                rewrite_refs(v);
            }
        }
        serde_json::Value::Array(arr) => {
            for v in arr {
                rewrite_refs(v);
            }
        }
        _ => {}
    }
}

/// Run `rustfmt` on a Rust source string, returning the formatted output.
fn run_rustfmt(code: &str) -> Result<String> {
    use std::io::Write;
    use std::process::{Command, Stdio};

    let mut child = Command::new("rustfmt")
        .arg("--edition")
        .arg("2024")
        .stdin(Stdio::piped())
        .stdout(Stdio::piped())
        .stderr(Stdio::piped())
        .spawn()
        .context("spawning rustfmt (is it installed?)")?;

    child
        .stdin
        .take()
        .context("opening rustfmt stdin")?
        .write_all(code.as_bytes())
        .context("writing to rustfmt stdin")?;

    let output = child.wait_with_output().context("waiting for rustfmt")?;

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        anyhow::bail!("rustfmt failed: {stderr}");
    }

    String::from_utf8(output.stdout).context("rustfmt produced non-UTF-8 output")
}

/// Write content to a file, or in check mode, verify the file matches.
fn write_or_check(path: &Path, content: &str, check_only: bool) -> Result<()> {
    let rel = path.strip_prefix(project_root()).unwrap_or(path).display();

    if check_only {
        let existing = std::fs::read_to_string(path)
            .with_context(|| format!("reading {rel} (does it exist?)"))?;
        if existing != content {
            anyhow::bail!(
                "Generated code is out of date: {rel}\nRun `cargo xtask generate` to update."
            );
        }
        eprintln!("  OK  {rel}");
    } else {
        std::fs::write(path, content).with_context(|| format!("writing {rel}"))?;
        eprintln!("  GEN {rel}");
    }
    Ok(())
}
