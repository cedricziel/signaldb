// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceByIdRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub trace_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub block_start: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub block_end: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub query_mode: ::prost::alloc::string::String,
    #[prost(bool, tag = "6")]
    pub allow_partial_trace: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceByIdResponse {
    #[prost(message, optional, tag = "1")]
    pub trace: ::core::option::Option<Trace>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<TraceByIdMetrics>,
    #[prost(enumeration = "trace_by_id_response::Status", tag = "3")]
    pub status: i32,
    #[prost(string, tag = "4")]
    pub message: ::prost::alloc::string::String,
}
/// Nested message and enum types in `TraceByIDResponse`.
pub mod trace_by_id_response {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Complete = 0,
        Partial = 1,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Complete => "COMPLETE",
                Self::Partial => "PARTIAL",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "COMPLETE" => Some(Self::Complete),
                "PARTIAL" => Some(Self::Partial),
                _ => None,
            }
        }
    }
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct TraceByIdMetrics {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchRequest {
    #[prost(map = "string, string", tag = "1")]
    pub tags: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    #[prost(uint32, tag = "2")]
    pub min_duration_ms: u32,
    #[prost(uint32, tag = "3")]
    pub max_duration_ms: u32,
    #[prost(uint32, tag = "4")]
    pub limit: u32,
    #[prost(uint32, tag = "5")]
    pub start: u32,
    #[prost(uint32, tag = "6")]
    pub end: u32,
    #[prost(string, tag = "8")]
    pub query: ::prost::alloc::string::String,
    #[prost(uint32, tag = "9")]
    pub spans_per_span_set: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchBlockRequest {
    #[prost(message, optional, tag = "1")]
    pub search_req: ::core::option::Option<SearchRequest>,
    #[prost(string, tag = "2")]
    pub block_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub start_page: u32,
    #[prost(uint32, tag = "4")]
    pub pages_to_search: u32,
    #[prost(string, tag = "5")]
    pub encoding: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub index_page_size: u32,
    #[prost(uint32, tag = "7")]
    pub total_records: u32,
    #[prost(string, tag = "8")]
    pub data_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "10")]
    pub size: u64,
    #[prost(uint32, tag = "11")]
    pub footer_size: u32,
    #[prost(message, repeated, tag = "12")]
    pub dedicated_columns: ::prost::alloc::vec::Vec<DedicatedColumn>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DedicatedColumn {
    #[prost(enumeration = "dedicated_column::Scope", tag = "3")]
    pub scope: i32,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(enumeration = "dedicated_column::Type", tag = "1")]
    pub r#type: i32,
}
/// Nested message and enum types in `DedicatedColumn`.
pub mod dedicated_column {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Scope {
        Span = 0,
        Resource = 1,
    }
    impl Scope {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Span => "SPAN",
                Self::Resource => "RESOURCE",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "SPAN" => Some(Self::Span),
                "RESOURCE" => Some(Self::Resource),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        String = 0,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::String => "STRING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STRING" => Some(Self::String),
                _ => None,
            }
        }
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchResponse {
    #[prost(message, repeated, tag = "1")]
    pub traces: ::prost::alloc::vec::Vec<TraceSearchMetadata>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<SearchMetrics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceSearchMetadata {
    #[prost(string, tag = "1")]
    pub trace_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub root_service_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub root_trace_name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub start_time_unix_nano: u64,
    #[prost(uint32, tag = "5")]
    pub duration_ms: u32,
    #[prost(message, optional, tag = "6")]
    pub span_set: ::core::option::Option<SpanSet>,
    #[prost(message, repeated, tag = "7")]
    pub span_sets: ::prost::alloc::vec::Vec<SpanSet>,
    #[prost(map = "string, message", tag = "8")]
    pub service_stats: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ServiceStats,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ServiceStats {
    #[prost(uint32, tag = "1")]
    pub span_count: u32,
    #[prost(uint32, tag = "2")]
    pub error_count: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanSet {
    #[prost(message, repeated, tag = "1")]
    pub spans: ::prost::alloc::vec::Vec<Span>,
    #[prost(uint32, tag = "2")]
    pub matched: u32,
    #[prost(message, repeated, tag = "3")]
    pub attributes: ::prost::alloc::vec::Vec<common::v1::KeyValue>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Span {
    #[prost(string, tag = "1")]
    pub span_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub start_time_unix_nano: u64,
    #[prost(uint64, tag = "4")]
    pub duration_nanos: u64,
    #[prost(message, repeated, tag = "5")]
    pub attributes: ::prost::alloc::vec::Vec<common::v1::KeyValue>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SearchMetrics {
    #[prost(uint32, tag = "1")]
    pub inspected_traces: u32,
    #[prost(uint64, tag = "2")]
    pub inspected_bytes: u64,
    #[prost(uint32, tag = "3")]
    pub total_blocks: u32,
    #[prost(uint32, tag = "4")]
    pub completed_jobs: u32,
    #[prost(uint32, tag = "5")]
    pub total_jobs: u32,
    #[prost(uint64, tag = "6")]
    pub total_block_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub inspected_spans: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagsRequest {
    #[prost(string, tag = "1")]
    pub scope: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub start: u32,
    #[prost(uint32, tag = "4")]
    pub end: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagsBlockRequest {
    #[prost(message, optional, tag = "1")]
    pub search_req: ::core::option::Option<SearchTagsRequest>,
    #[prost(string, tag = "2")]
    pub block_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub start_page: u32,
    #[prost(uint32, tag = "4")]
    pub pages_to_search: u32,
    #[prost(string, tag = "5")]
    pub encoding: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub index_page_size: u32,
    #[prost(uint32, tag = "7")]
    pub total_records: u32,
    #[prost(string, tag = "8")]
    pub data_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "10")]
    pub size: u64,
    #[prost(uint32, tag = "11")]
    pub footer_size: u32,
    #[prost(message, repeated, tag = "12")]
    pub dedicated_columns: ::prost::alloc::vec::Vec<DedicatedColumn>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagValuesBlockRequest {
    #[prost(message, optional, tag = "1")]
    pub search_req: ::core::option::Option<SearchTagValuesRequest>,
    #[prost(string, tag = "2")]
    pub block_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub start_page: u32,
    #[prost(uint32, tag = "4")]
    pub pages_to_search: u32,
    #[prost(string, tag = "5")]
    pub encoding: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub index_page_size: u32,
    #[prost(uint32, tag = "7")]
    pub total_records: u32,
    #[prost(string, tag = "8")]
    pub data_encoding: ::prost::alloc::string::String,
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "10")]
    pub size: u64,
    #[prost(uint32, tag = "11")]
    pub footer_size: u32,
    #[prost(message, repeated, tag = "12")]
    pub dedicated_columns: ::prost::alloc::vec::Vec<DedicatedColumn>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagsResponse {
    #[prost(string, repeated, tag = "1")]
    pub tag_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<MetadataMetrics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagsV2Response {
    #[prost(message, repeated, tag = "1")]
    pub scopes: ::prost::alloc::vec::Vec<SearchTagsV2Scope>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<MetadataMetrics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagsV2Scope {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagValuesRequest {
    #[prost(string, tag = "1")]
    pub tag_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query: ::prost::alloc::string::String,
    #[prost(uint32, tag = "4")]
    pub start: u32,
    #[prost(uint32, tag = "5")]
    pub end: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagValuesResponse {
    #[prost(string, repeated, tag = "1")]
    pub tag_values: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<MetadataMetrics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TagValue {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SearchTagValuesV2Response {
    #[prost(message, repeated, tag = "1")]
    pub tag_values: ::prost::alloc::vec::Vec<TagValue>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<MetadataMetrics>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MetadataMetrics {
    #[prost(uint64, tag = "1")]
    pub inspected_bytes: u64,
    #[prost(uint32, tag = "2")]
    pub total_jobs: u32,
    #[prost(uint32, tag = "3")]
    pub completed_jobs: u32,
    #[prost(uint32, tag = "4")]
    pub total_blocks: u32,
    #[prost(uint64, tag = "5")]
    pub total_block_bytes: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Trace {
    #[prost(message, repeated, tag = "1")]
    pub resource_spans: ::prost::alloc::vec::Vec<trace::v1::ResourceSpans>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushResponse {
    #[prost(enumeration = "PushErrorReason", repeated, tag = "1")]
    pub errors_by_trace: ::prost::alloc::vec::Vec<i32>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushBytesRequest {
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub traces: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub ids: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub search_data: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PushSpansRequest {
    #[prost(message, repeated, tag = "1")]
    pub batches: ::prost::alloc::vec::Vec<trace::v1::ResourceSpans>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceBytes {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub traces: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinkSlice {
    #[prost(message, repeated, tag = "1")]
    pub links: ::prost::alloc::vec::Vec<trace::v1::span::Link>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsRequest {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_by: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint32, tag = "4")]
    pub start: u32,
    #[prost(uint32, tag = "5")]
    pub end: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsSummaryRequest {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub group_by: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint32, tag = "4")]
    pub start: u32,
    #[prost(uint32, tag = "5")]
    pub end: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsResponse {
    #[prost(bool, tag = "1")]
    pub estimated: bool,
    #[prost(uint64, tag = "2")]
    pub span_count: u64,
    #[prost(uint64, tag = "3")]
    pub error_span_count: u64,
    #[prost(message, repeated, tag = "4")]
    pub metrics: ::prost::alloc::vec::Vec<SpanMetrics>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct RawHistogram {
    #[prost(uint64, tag = "1")]
    pub bucket: u64,
    #[prost(uint64, tag = "2")]
    pub count: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyValue {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<TraceQlStatic>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetrics {
    #[prost(message, repeated, tag = "1")]
    pub latency_histogram: ::prost::alloc::vec::Vec<RawHistogram>,
    #[prost(message, repeated, tag = "2")]
    pub series: ::prost::alloc::vec::Vec<KeyValue>,
    #[prost(uint64, tag = "3")]
    pub errors: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsSummary {
    #[prost(uint64, tag = "1")]
    pub span_count: u64,
    #[prost(uint64, tag = "2")]
    pub error_span_count: u64,
    #[prost(message, repeated, tag = "3")]
    pub series: ::prost::alloc::vec::Vec<KeyValue>,
    #[prost(uint64, tag = "4")]
    pub p99: u64,
    #[prost(uint64, tag = "5")]
    pub p95: u64,
    #[prost(uint64, tag = "6")]
    pub p90: u64,
    #[prost(uint64, tag = "7")]
    pub p50: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsSummaryResponse {
    #[prost(message, repeated, tag = "1")]
    pub summaries: ::prost::alloc::vec::Vec<SpanMetricsSummary>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TraceQlStatic {
    #[prost(int32, tag = "1")]
    pub r#type: i32,
    #[prost(int64, tag = "2")]
    pub n: i64,
    #[prost(double, tag = "3")]
    pub f: f64,
    #[prost(string, tag = "4")]
    pub s: ::prost::alloc::string::String,
    #[prost(bool, tag = "5")]
    pub b: bool,
    #[prost(uint64, tag = "6")]
    pub d: u64,
    #[prost(int32, tag = "7")]
    pub status: i32,
    #[prost(int32, tag = "8")]
    pub kind: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsData {
    #[prost(string, tag = "1")]
    pub result_type: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub result: ::prost::alloc::vec::Vec<SpanMetricsResult>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsResult {
    #[prost(string, tag = "1")]
    pub label_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub label_value: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub ts: ::prost::alloc::vec::Vec<SpanMetricsResultPoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SpanMetricsResultPoint {
    #[prost(uint32, tag = "1")]
    pub time: u32,
    #[prost(double, tag = "2")]
    pub val: f64,
    #[prost(bytes = "vec", tag = "3")]
    pub exemplar_trace_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub exemplar_duration: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInstantRequest {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub start: u64,
    #[prost(uint64, tag = "3")]
    pub end: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryInstantResponse {
    #[prost(message, repeated, tag = "1")]
    pub series: ::prost::alloc::vec::Vec<InstantSeries>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<SearchMetrics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InstantSeries {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<common::v1::KeyValue>,
    #[prost(double, tag = "2")]
    pub value: f64,
    #[prost(string, tag = "3")]
    pub prom_labels: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRangeRequest {
    #[prost(string, tag = "1")]
    pub query: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub start: u64,
    #[prost(uint64, tag = "3")]
    pub end: u64,
    #[prost(uint64, tag = "4")]
    pub step: u64,
    #[prost(string, tag = "7")]
    pub query_mode: ::prost::alloc::string::String,
    #[prost(string, tag = "8")]
    pub block_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "9")]
    pub start_page: u32,
    #[prost(uint32, tag = "10")]
    pub pages_to_search: u32,
    #[prost(string, tag = "11")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "12")]
    pub encoding: ::prost::alloc::string::String,
    #[prost(uint64, tag = "13")]
    pub size: u64,
    #[prost(uint32, tag = "14")]
    pub footer_size: u32,
    #[prost(message, repeated, tag = "15")]
    pub dedicated_columns: ::prost::alloc::vec::Vec<DedicatedColumn>,
    #[prost(uint32, tag = "16")]
    pub exemplars: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryRangeResponse {
    #[prost(message, repeated, tag = "1")]
    pub series: ::prost::alloc::vec::Vec<TimeSeries>,
    #[prost(message, optional, tag = "2")]
    pub metrics: ::core::option::Option<SearchMetrics>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Exemplar {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<common::v1::KeyValue>,
    #[prost(double, tag = "2")]
    pub value: f64,
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Sample {
    #[prost(int64, tag = "2")]
    pub timestamp_ms: i64,
    #[prost(double, tag = "1")]
    pub value: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeSeries {
    #[prost(message, repeated, tag = "1")]
    pub labels: ::prost::alloc::vec::Vec<common::v1::KeyValue>,
    #[prost(message, repeated, tag = "2")]
    pub samples: ::prost::alloc::vec::Vec<Sample>,
    #[prost(string, tag = "3")]
    pub prom_labels: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "4")]
    pub exemplars: ::prost::alloc::vec::Vec<Exemplar>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PushErrorReason {
    NoError = 0,
    MaxLiveTraces = 1,
    TraceTooLarge = 2,
    UnknownError = 3,
}
impl PushErrorReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NoError => "NO_ERROR",
            Self::MaxLiveTraces => "MAX_LIVE_TRACES",
            Self::TraceTooLarge => "TRACE_TOO_LARGE",
            Self::UnknownError => "UNKNOWN_ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NO_ERROR" => Some(Self::NoError),
            "MAX_LIVE_TRACES" => Some(Self::MaxLiveTraces),
            "TRACE_TOO_LARGE" => Some(Self::TraceTooLarge),
            "UNKNOWN_ERROR" => Some(Self::UnknownError),
            _ => None,
        }
    }
}
