// This file is generated by `cargo xtask generate`. Do not edit.

#[allow(unused_imports)]
pub use progenitor_client::{ByteStream, ClientInfo, Error, ResponseValue};
#[allow(unused_imports)]
use progenitor_client::{ClientHooks, OperationInfo, RequestBuilderExt, encode_path};
/// Types used as operation parameters and responses.
#[allow(clippy::all)]
pub mod types {
    /// Error types.
    pub mod error {
        /// Error from a `TryFrom` or `FromStr` implementation.
        pub struct ConversionError(::std::borrow::Cow<'static, str>);
        impl ::std::error::Error for ConversionError {}
        impl ::std::fmt::Display for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Display::fmt(&self.0, f)
            }
        }
        impl ::std::fmt::Debug for ConversionError {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
                ::std::fmt::Debug::fmt(&self.0, f)
            }
        }
        impl From<&'static str> for ConversionError {
            fn from(value: &'static str) -> Self {
                Self(value.into())
            }
        }
        impl From<String> for ConversionError {
            fn from(value: String) -> Self {
                Self(value.into())
            }
        }
    }
    ///Standard API error response
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Standard API error response",
    ///  "type": "object",
    ///  "required": [
    ///    "error",
    ///    "message"
    ///  ],
    ///  "properties": {
    ///    "error": {
    ///      "description": "Error category",
    ///      "type": "string"
    ///    },
    ///    "message": {
    ///      "description": "Human-readable error description",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ApiError {
        ///Error category
        pub error: ::std::string::String,
        ///Human-readable error description
        pub message: ::std::string::String,
    }
    impl ::std::convert::From<&ApiError> for ApiError {
        fn from(value: &ApiError) -> Self {
            value.clone()
        }
    }
    impl ApiError {
        pub fn builder() -> builder::ApiError {
            Default::default()
        }
    }
    ///API key information (without the raw key)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "API key information (without the raw key)",
    ///  "type": "object",
    ///  "required": [
    ///    "created_at",
    ///    "id"
    ///  ],
    ///  "properties": {
    ///    "created_at": {
    ///      "description": "ISO 8601 creation timestamp",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "Unique key identifier",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Optional human-readable name",
    ///      "type": "string"
    ///    },
    ///    "revoked_at": {
    ///      "description": "ISO 8601 revocation timestamp (if revoked)",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ApiKeyResponse {
        ///ISO 8601 creation timestamp
        pub created_at: ::std::string::String,
        ///Unique key identifier
        pub id: ::std::string::String,
        ///Optional human-readable name
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
        ///ISO 8601 revocation timestamp (if revoked)
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub revoked_at: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&ApiKeyResponse> for ApiKeyResponse {
        fn from(value: &ApiKeyResponse) -> Self {
            value.clone()
        }
    }
    impl ApiKeyResponse {
        pub fn builder() -> builder::ApiKeyResponse {
            Default::default()
        }
    }
    ///Request body for creating a new API key
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request body for creating a new API key",
    ///  "type": "object",
    ///  "properties": {
    ///    "name": {
    ///      "description": "Optional human-readable name for the key",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateApiKeyRequest {
        ///Optional human-readable name for the key
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&CreateApiKeyRequest> for CreateApiKeyRequest {
        fn from(value: &CreateApiKeyRequest) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for CreateApiKeyRequest {
        fn default() -> Self {
            Self {
                name: Default::default(),
            }
        }
    }
    impl CreateApiKeyRequest {
        pub fn builder() -> builder::CreateApiKeyRequest {
            Default::default()
        }
    }
    ///Response returned when a new API key is created (includes the raw key)
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response returned when a new API key is created (includes the raw key)",
    ///  "type": "object",
    ///  "required": [
    ///    "created_at",
    ///    "id",
    ///    "key"
    ///  ],
    ///  "properties": {
    ///    "created_at": {
    ///      "description": "ISO 8601 creation timestamp",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "Unique key identifier",
    ///      "type": "string"
    ///    },
    ///    "key": {
    ///      "description": "The raw API key (only shown once at creation time)",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Optional human-readable name",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateApiKeyResponse {
        ///ISO 8601 creation timestamp
        pub created_at: ::std::string::String,
        ///Unique key identifier
        pub id: ::std::string::String,
        ///The raw API key (only shown once at creation time)
        pub key: ::std::string::String,
        ///Optional human-readable name
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&CreateApiKeyResponse> for CreateApiKeyResponse {
        fn from(value: &CreateApiKeyResponse) -> Self {
            value.clone()
        }
    }
    impl CreateApiKeyResponse {
        pub fn builder() -> builder::CreateApiKeyResponse {
            Default::default()
        }
    }
    ///Request body for creating a new dataset
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request body for creating a new dataset",
    ///  "type": "object",
    ///  "required": [
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "name": {
    ///      "description": "Dataset name",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateDatasetRequest {
        ///Dataset name
        pub name: ::std::string::String,
    }
    impl ::std::convert::From<&CreateDatasetRequest> for CreateDatasetRequest {
        fn from(value: &CreateDatasetRequest) -> Self {
            value.clone()
        }
    }
    impl CreateDatasetRequest {
        pub fn builder() -> builder::CreateDatasetRequest {
            Default::default()
        }
    }
    ///Request body for creating a new tenant
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request body for creating a new tenant",
    ///  "type": "object",
    ///  "required": [
    ///    "id",
    ///    "name"
    ///  ],
    ///  "properties": {
    ///    "default_dataset": {
    ///      "description": "Default dataset name",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "Unique tenant identifier",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Human-readable tenant name",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct CreateTenantRequest {
        ///Default dataset name
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub default_dataset: ::std::option::Option<::std::string::String>,
        ///Unique tenant identifier
        pub id: ::std::string::String,
        ///Human-readable tenant name
        pub name: ::std::string::String,
    }
    impl ::std::convert::From<&CreateTenantRequest> for CreateTenantRequest {
        fn from(value: &CreateTenantRequest) -> Self {
            value.clone()
        }
    }
    impl CreateTenantRequest {
        pub fn builder() -> builder::CreateTenantRequest {
            Default::default()
        }
    }
    ///Dataset information returned by the API
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Dataset information returned by the API",
    ///  "type": "object",
    ///  "required": [
    ///    "created_at",
    ///    "id",
    ///    "name",
    ///    "tenant_id"
    ///  ],
    ///  "properties": {
    ///    "created_at": {
    ///      "description": "ISO 8601 creation timestamp",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "Unique dataset identifier",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Dataset name",
    ///      "type": "string"
    ///    },
    ///    "tenant_id": {
    ///      "description": "Tenant that owns this dataset",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct DatasetResponse {
        ///ISO 8601 creation timestamp
        pub created_at: ::std::string::String,
        ///Unique dataset identifier
        pub id: ::std::string::String,
        ///Dataset name
        pub name: ::std::string::String,
        ///Tenant that owns this dataset
        pub tenant_id: ::std::string::String,
    }
    impl ::std::convert::From<&DatasetResponse> for DatasetResponse {
        fn from(value: &DatasetResponse) -> Self {
            value.clone()
        }
    }
    impl DatasetResponse {
        pub fn builder() -> builder::DatasetResponse {
            Default::default()
        }
    }
    ///Response containing a list of API keys
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response containing a list of API keys",
    ///  "type": "object",
    ///  "required": [
    ///    "api_keys"
    ///  ],
    ///  "properties": {
    ///    "api_keys": {
    ///      "description": "List of API key records (without raw keys)",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/ApiKeyResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListApiKeysResponse {
        ///List of API key records (without raw keys)
        pub api_keys: ::std::vec::Vec<ApiKeyResponse>,
    }
    impl ::std::convert::From<&ListApiKeysResponse> for ListApiKeysResponse {
        fn from(value: &ListApiKeysResponse) -> Self {
            value.clone()
        }
    }
    impl ListApiKeysResponse {
        pub fn builder() -> builder::ListApiKeysResponse {
            Default::default()
        }
    }
    ///Response containing a list of datasets
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response containing a list of datasets",
    ///  "type": "object",
    ///  "required": [
    ///    "datasets"
    ///  ],
    ///  "properties": {
    ///    "datasets": {
    ///      "description": "List of dataset records",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/DatasetResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListDatasetsResponse {
        ///List of dataset records
        pub datasets: ::std::vec::Vec<DatasetResponse>,
    }
    impl ::std::convert::From<&ListDatasetsResponse> for ListDatasetsResponse {
        fn from(value: &ListDatasetsResponse) -> Self {
            value.clone()
        }
    }
    impl ListDatasetsResponse {
        pub fn builder() -> builder::ListDatasetsResponse {
            Default::default()
        }
    }
    ///Response containing a list of tenants
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Response containing a list of tenants",
    ///  "type": "object",
    ///  "required": [
    ///    "tenants"
    ///  ],
    ///  "properties": {
    ///    "tenants": {
    ///      "description": "List of tenant records",
    ///      "type": "array",
    ///      "items": {
    ///        "$ref": "#/components/schemas/TenantResponse"
    ///      }
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct ListTenantsResponse {
        ///List of tenant records
        pub tenants: ::std::vec::Vec<TenantResponse>,
    }
    impl ::std::convert::From<&ListTenantsResponse> for ListTenantsResponse {
        fn from(value: &ListTenantsResponse) -> Self {
            value.clone()
        }
    }
    impl ListTenantsResponse {
        pub fn builder() -> builder::ListTenantsResponse {
            Default::default()
        }
    }
    ///Tenant information returned by the API
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Tenant information returned by the API",
    ///  "type": "object",
    ///  "required": [
    ///    "created_at",
    ///    "id",
    ///    "name",
    ///    "source",
    ///    "updated_at"
    ///  ],
    ///  "properties": {
    ///    "created_at": {
    ///      "description": "ISO 8601 creation timestamp",
    ///      "type": "string"
    ///    },
    ///    "default_dataset": {
    ///      "description": "Default dataset name",
    ///      "type": "string"
    ///    },
    ///    "id": {
    ///      "description": "Unique tenant identifier",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Human-readable tenant name",
    ///      "type": "string"
    ///    },
    ///    "source": {
    ///      "description": "Source of the tenant record (config or database)",
    ///      "type": "string"
    ///    },
    ///    "updated_at": {
    ///      "description": "ISO 8601 last-updated timestamp",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct TenantResponse {
        ///ISO 8601 creation timestamp
        pub created_at: ::std::string::String,
        ///Default dataset name
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub default_dataset: ::std::option::Option<::std::string::String>,
        ///Unique tenant identifier
        pub id: ::std::string::String,
        ///Human-readable tenant name
        pub name: ::std::string::String,
        ///Source of the tenant record (config or database)
        pub source: ::std::string::String,
        ///ISO 8601 last-updated timestamp
        pub updated_at: ::std::string::String,
    }
    impl ::std::convert::From<&TenantResponse> for TenantResponse {
        fn from(value: &TenantResponse) -> Self {
            value.clone()
        }
    }
    impl TenantResponse {
        pub fn builder() -> builder::TenantResponse {
            Default::default()
        }
    }
    ///Request body for updating an existing tenant
    ///
    /// <details><summary>JSON schema</summary>
    ///
    /// ```json
    ///{
    ///  "description": "Request body for updating an existing tenant",
    ///  "type": "object",
    ///  "properties": {
    ///    "default_dataset": {
    ///      "description": "Updated default dataset",
    ///      "type": "string"
    ///    },
    ///    "name": {
    ///      "description": "Updated tenant name",
    ///      "type": "string"
    ///    }
    ///  }
    ///}
    /// ```
    /// </details>
    #[derive(::serde::Deserialize, ::serde::Serialize, Clone, Debug)]
    pub struct UpdateTenantRequest {
        ///Updated default dataset
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub default_dataset: ::std::option::Option<::std::string::String>,
        ///Updated tenant name
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        pub name: ::std::option::Option<::std::string::String>,
    }
    impl ::std::convert::From<&UpdateTenantRequest> for UpdateTenantRequest {
        fn from(value: &UpdateTenantRequest) -> Self {
            value.clone()
        }
    }
    impl ::std::default::Default for UpdateTenantRequest {
        fn default() -> Self {
            Self {
                default_dataset: Default::default(),
                name: Default::default(),
            }
        }
    }
    impl UpdateTenantRequest {
        pub fn builder() -> builder::UpdateTenantRequest {
            Default::default()
        }
    }
    /// Types for composing complex structures.
    pub mod builder {
        #[derive(Clone, Debug)]
        pub struct ApiError {
            error: ::std::result::Result<::std::string::String, ::std::string::String>,
            message: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for ApiError {
            fn default() -> Self {
                Self {
                    error: Err("no value supplied for error".to_string()),
                    message: Err("no value supplied for message".to_string()),
                }
            }
        }
        impl ApiError {
            pub fn error<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.error = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for error: {}", e));
                self
            }
            pub fn message<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.message = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for message: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ApiError> for super::ApiError {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApiError,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    error: value.error?,
                    message: value.message?,
                })
            }
        }
        impl ::std::convert::From<super::ApiError> for ApiError {
            fn from(value: super::ApiError) -> Self {
                Self {
                    error: Ok(value.error),
                    message: Ok(value.message),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ApiKeyResponse {
            created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            revoked_at: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ApiKeyResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Ok(Default::default()),
                    revoked_at: Ok(Default::default()),
                }
            }
        }
        impl ApiKeyResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn revoked_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.revoked_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for revoked_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ApiKeyResponse> for super::ApiKeyResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ApiKeyResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    name: value.name?,
                    revoked_at: value.revoked_at?,
                })
            }
        }
        impl ::std::convert::From<super::ApiKeyResponse> for ApiKeyResponse {
            fn from(value: super::ApiKeyResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    revoked_at: Ok(value.revoked_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateApiKeyRequest {
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateApiKeyRequest {
            fn default() -> Self {
                Self {
                    name: Ok(Default::default()),
                }
            }
        }
        impl CreateApiKeyRequest {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateApiKeyRequest> for super::CreateApiKeyRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateApiKeyRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { name: value.name? })
            }
        }
        impl ::std::convert::From<super::CreateApiKeyRequest> for CreateApiKeyRequest {
            fn from(value: super::CreateApiKeyRequest) -> Self {
                Self {
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateApiKeyResponse {
            created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            key: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for CreateApiKeyResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    key: Err("no value supplied for key".to_string()),
                    name: Ok(Default::default()),
                }
            }
        }
        impl CreateApiKeyResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn key<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.key = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for key: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateApiKeyResponse> for super::CreateApiKeyResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateApiKeyResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    key: value.key?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::CreateApiKeyResponse> for CreateApiKeyResponse {
            fn from(value: super::CreateApiKeyResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    key: Ok(value.key),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateDatasetRequest {
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateDatasetRequest {
            fn default() -> Self {
                Self {
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl CreateDatasetRequest {
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateDatasetRequest> for super::CreateDatasetRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateDatasetRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self { name: value.name? })
            }
        }
        impl ::std::convert::From<super::CreateDatasetRequest> for CreateDatasetRequest {
            fn from(value: super::CreateDatasetRequest) -> Self {
                Self {
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct CreateTenantRequest {
            default_dataset: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for CreateTenantRequest {
            fn default() -> Self {
                Self {
                    default_dataset: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                }
            }
        }
        impl CreateTenantRequest {
            pub fn default_dataset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.default_dataset = value.try_into().map_err(|e| {
                    format!("error converting supplied value for default_dataset: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<CreateTenantRequest> for super::CreateTenantRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: CreateTenantRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    default_dataset: value.default_dataset?,
                    id: value.id?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::CreateTenantRequest> for CreateTenantRequest {
            fn from(value: super::CreateTenantRequest) -> Self {
                Self {
                    default_dataset: Ok(value.default_dataset),
                    id: Ok(value.id),
                    name: Ok(value.name),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct DatasetResponse {
            created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            tenant_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for DatasetResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    tenant_id: Err("no value supplied for tenant_id".to_string()),
                }
            }
        }
        impl DatasetResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn tenant_id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.tenant_id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tenant_id: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<DatasetResponse> for super::DatasetResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: DatasetResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    id: value.id?,
                    name: value.name?,
                    tenant_id: value.tenant_id?,
                })
            }
        }
        impl ::std::convert::From<super::DatasetResponse> for DatasetResponse {
            fn from(value: super::DatasetResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    tenant_id: Ok(value.tenant_id),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListApiKeysResponse {
            api_keys: ::std::result::Result<
                ::std::vec::Vec<super::ApiKeyResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListApiKeysResponse {
            fn default() -> Self {
                Self {
                    api_keys: Err("no value supplied for api_keys".to_string()),
                }
            }
        }
        impl ListApiKeysResponse {
            pub fn api_keys<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::ApiKeyResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.api_keys = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for api_keys: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ListApiKeysResponse> for super::ListApiKeysResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListApiKeysResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    api_keys: value.api_keys?,
                })
            }
        }
        impl ::std::convert::From<super::ListApiKeysResponse> for ListApiKeysResponse {
            fn from(value: super::ListApiKeysResponse) -> Self {
                Self {
                    api_keys: Ok(value.api_keys),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListDatasetsResponse {
            datasets: ::std::result::Result<
                ::std::vec::Vec<super::DatasetResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListDatasetsResponse {
            fn default() -> Self {
                Self {
                    datasets: Err("no value supplied for datasets".to_string()),
                }
            }
        }
        impl ListDatasetsResponse {
            pub fn datasets<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::DatasetResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.datasets = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for datasets: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ListDatasetsResponse> for super::ListDatasetsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListDatasetsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    datasets: value.datasets?,
                })
            }
        }
        impl ::std::convert::From<super::ListDatasetsResponse> for ListDatasetsResponse {
            fn from(value: super::ListDatasetsResponse) -> Self {
                Self {
                    datasets: Ok(value.datasets),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct ListTenantsResponse {
            tenants: ::std::result::Result<
                ::std::vec::Vec<super::TenantResponse>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for ListTenantsResponse {
            fn default() -> Self {
                Self {
                    tenants: Err("no value supplied for tenants".to_string()),
                }
            }
        }
        impl ListTenantsResponse {
            pub fn tenants<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::vec::Vec<super::TenantResponse>>,
                T::Error: ::std::fmt::Display,
            {
                self.tenants = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for tenants: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<ListTenantsResponse> for super::ListTenantsResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: ListTenantsResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    tenants: value.tenants?,
                })
            }
        }
        impl ::std::convert::From<super::ListTenantsResponse> for ListTenantsResponse {
            fn from(value: super::ListTenantsResponse) -> Self {
                Self {
                    tenants: Ok(value.tenants),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct TenantResponse {
            created_at: ::std::result::Result<::std::string::String, ::std::string::String>,
            default_dataset: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            id: ::std::result::Result<::std::string::String, ::std::string::String>,
            name: ::std::result::Result<::std::string::String, ::std::string::String>,
            source: ::std::result::Result<::std::string::String, ::std::string::String>,
            updated_at: ::std::result::Result<::std::string::String, ::std::string::String>,
        }
        impl ::std::default::Default for TenantResponse {
            fn default() -> Self {
                Self {
                    created_at: Err("no value supplied for created_at".to_string()),
                    default_dataset: Ok(Default::default()),
                    id: Err("no value supplied for id".to_string()),
                    name: Err("no value supplied for name".to_string()),
                    source: Err("no value supplied for source".to_string()),
                    updated_at: Err("no value supplied for updated_at".to_string()),
                }
            }
        }
        impl TenantResponse {
            pub fn created_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.created_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for created_at: {}", e));
                self
            }
            pub fn default_dataset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.default_dataset = value.try_into().map_err(|e| {
                    format!("error converting supplied value for default_dataset: {}", e)
                });
                self
            }
            pub fn id<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.id = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for id: {}", e));
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
            pub fn source<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.source = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for source: {}", e));
                self
            }
            pub fn updated_at<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::string::String>,
                T::Error: ::std::fmt::Display,
            {
                self.updated_at = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for updated_at: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<TenantResponse> for super::TenantResponse {
            type Error = super::error::ConversionError;
            fn try_from(
                value: TenantResponse,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    created_at: value.created_at?,
                    default_dataset: value.default_dataset?,
                    id: value.id?,
                    name: value.name?,
                    source: value.source?,
                    updated_at: value.updated_at?,
                })
            }
        }
        impl ::std::convert::From<super::TenantResponse> for TenantResponse {
            fn from(value: super::TenantResponse) -> Self {
                Self {
                    created_at: Ok(value.created_at),
                    default_dataset: Ok(value.default_dataset),
                    id: Ok(value.id),
                    name: Ok(value.name),
                    source: Ok(value.source),
                    updated_at: Ok(value.updated_at),
                }
            }
        }
        #[derive(Clone, Debug)]
        pub struct UpdateTenantRequest {
            default_dataset: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
            name: ::std::result::Result<
                ::std::option::Option<::std::string::String>,
                ::std::string::String,
            >,
        }
        impl ::std::default::Default for UpdateTenantRequest {
            fn default() -> Self {
                Self {
                    default_dataset: Ok(Default::default()),
                    name: Ok(Default::default()),
                }
            }
        }
        impl UpdateTenantRequest {
            pub fn default_dataset<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.default_dataset = value.try_into().map_err(|e| {
                    format!("error converting supplied value for default_dataset: {}", e)
                });
                self
            }
            pub fn name<T>(mut self, value: T) -> Self
            where
                T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
                T::Error: ::std::fmt::Display,
            {
                self.name = value
                    .try_into()
                    .map_err(|e| format!("error converting supplied value for name: {}", e));
                self
            }
        }
        impl ::std::convert::TryFrom<UpdateTenantRequest> for super::UpdateTenantRequest {
            type Error = super::error::ConversionError;
            fn try_from(
                value: UpdateTenantRequest,
            ) -> ::std::result::Result<Self, super::error::ConversionError> {
                Ok(Self {
                    default_dataset: value.default_dataset?,
                    name: value.name?,
                })
            }
        }
        impl ::std::convert::From<super::UpdateTenantRequest> for UpdateTenantRequest {
            fn from(value: super::UpdateTenantRequest) -> Self {
                Self {
                    default_dataset: Ok(value.default_dataset),
                    name: Ok(value.name),
                }
            }
        }
    }
}
#[derive(Clone, Debug)]
/**Client for SignalDB Admin API

Tenant management API for SignalDB

Version: 1.0.0*/
pub struct Client {
    pub(crate) baseurl: String,
    pub(crate) client: reqwest::Client,
}
impl Client {
    /// Create a new client.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new(baseurl: &str) -> Self {
        #[cfg(not(target_arch = "wasm32"))]
        let client = {
            let dur = ::std::time::Duration::from_secs(15u64);
            reqwest::ClientBuilder::new()
                .connect_timeout(dur)
                .timeout(dur)
        };
        #[cfg(target_arch = "wasm32")]
        let client = reqwest::ClientBuilder::new();
        Self::new_with_client(baseurl, client.build().unwrap())
    }
    /// Construct a new client with an existing `reqwest::Client`,
    /// allowing more control over its configuration.
    ///
    /// `baseurl` is the base URL provided to the internal
    /// `reqwest::Client`, and should include a scheme and hostname,
    /// as well as port and a path stem if applicable.
    pub fn new_with_client(baseurl: &str, client: reqwest::Client) -> Self {
        Self {
            baseurl: baseurl.to_string(),
            client,
        }
    }
}
impl ClientInfo<()> for Client {
    fn api_version() -> &'static str {
        "1.0.0"
    }
    fn baseurl(&self) -> &str {
        self.baseurl.as_str()
    }
    fn client(&self) -> &reqwest::Client {
        &self.client
    }
    fn inner(&self) -> &() {
        &()
    }
}
impl ClientHooks<()> for &Client {}
impl Client {
    /**List all tenants

    Sends a `GET` request to `/tenants`

    ```ignore
    let response = client.list_tenants()
        .send()
        .await;
    ```*/
    pub fn list_tenants(&self) -> builder::ListTenants<'_> {
        builder::ListTenants::new(self)
    }
    /**Create a new tenant

    Sends a `POST` request to `/tenants`

    ```ignore
    let response = client.create_tenant()
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_tenant(&self) -> builder::CreateTenant<'_> {
        builder::CreateTenant::new(self)
    }
    /**Get a tenant by ID

    Sends a `GET` request to `/tenants/{tenant_id}`

    Arguments:
    - `tenant_id`: Tenant identifier
    ```ignore
    let response = client.get_tenant()
        .tenant_id(tenant_id)
        .send()
        .await;
    ```*/
    pub fn get_tenant(&self) -> builder::GetTenant<'_> {
        builder::GetTenant::new(self)
    }
    /**Update a tenant

    Sends a `PUT` request to `/tenants/{tenant_id}`

    Arguments:
    - `tenant_id`: Tenant identifier
    - `body`
    ```ignore
    let response = client.update_tenant()
        .tenant_id(tenant_id)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn update_tenant(&self) -> builder::UpdateTenant<'_> {
        builder::UpdateTenant::new(self)
    }
    /**Delete a tenant

    Sends a `DELETE` request to `/tenants/{tenant_id}`

    Arguments:
    - `tenant_id`: Tenant identifier
    ```ignore
    let response = client.delete_tenant()
        .tenant_id(tenant_id)
        .send()
        .await;
    ```*/
    pub fn delete_tenant(&self) -> builder::DeleteTenant<'_> {
        builder::DeleteTenant::new(self)
    }
    /**List API keys for a tenant

    Sends a `GET` request to `/tenants/{tenant_id}/api-keys`

    Arguments:
    - `tenant_id`: Tenant identifier
    ```ignore
    let response = client.list_api_keys()
        .tenant_id(tenant_id)
        .send()
        .await;
    ```*/
    pub fn list_api_keys(&self) -> builder::ListApiKeys<'_> {
        builder::ListApiKeys::new(self)
    }
    /**Create a new API key for a tenant

    Sends a `POST` request to `/tenants/{tenant_id}/api-keys`

    Arguments:
    - `tenant_id`: Tenant identifier
    - `body`
    ```ignore
    let response = client.create_api_key()
        .tenant_id(tenant_id)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_api_key(&self) -> builder::CreateApiKey<'_> {
        builder::CreateApiKey::new(self)
    }
    /**Revoke an API key

    Sends a `DELETE` request to `/tenants/{tenant_id}/api-keys/{key_id}`

    Arguments:
    - `tenant_id`: Tenant identifier
    - `key_id`: API key identifier
    ```ignore
    let response = client.revoke_api_key()
        .tenant_id(tenant_id)
        .key_id(key_id)
        .send()
        .await;
    ```*/
    pub fn revoke_api_key(&self) -> builder::RevokeApiKey<'_> {
        builder::RevokeApiKey::new(self)
    }
    /**List datasets for a tenant

    Sends a `GET` request to `/tenants/{tenant_id}/datasets`

    Arguments:
    - `tenant_id`: Tenant identifier
    ```ignore
    let response = client.list_datasets()
        .tenant_id(tenant_id)
        .send()
        .await;
    ```*/
    pub fn list_datasets(&self) -> builder::ListDatasets<'_> {
        builder::ListDatasets::new(self)
    }
    /**Create a new dataset for a tenant

    Sends a `POST` request to `/tenants/{tenant_id}/datasets`

    Arguments:
    - `tenant_id`: Tenant identifier
    - `body`
    ```ignore
    let response = client.create_dataset()
        .tenant_id(tenant_id)
        .body(body)
        .send()
        .await;
    ```*/
    pub fn create_dataset(&self) -> builder::CreateDataset<'_> {
        builder::CreateDataset::new(self)
    }
    /**Delete a dataset

    Sends a `DELETE` request to `/tenants/{tenant_id}/datasets/{dataset_id}`

    Arguments:
    - `tenant_id`: Tenant identifier
    - `dataset_id`: Dataset identifier
    ```ignore
    let response = client.delete_dataset()
        .tenant_id(tenant_id)
        .dataset_id(dataset_id)
        .send()
        .await;
    ```*/
    pub fn delete_dataset(&self) -> builder::DeleteDataset<'_> {
        builder::DeleteDataset::new(self)
    }
}
/// Types for composing operation parameters.
#[allow(clippy::all)]
pub mod builder {
    use super::types;
    #[allow(unused_imports)]
    use super::{
        ByteStream, ClientHooks, ClientInfo, Error, OperationInfo, RequestBuilderExt,
        ResponseValue, encode_path,
    };
    /**Builder for [`Client::list_tenants`]

    [`Client::list_tenants`]: super::Client::list_tenants*/
    #[derive(Debug, Clone)]
    pub struct ListTenants<'a> {
        client: &'a super::Client,
    }
    impl<'a> ListTenants<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self { client: client }
        }
        ///Sends a `GET` request to `/tenants`
        pub async fn send(self) -> Result<ResponseValue<types::ListTenantsResponse>, Error<()>> {
            let Self { client } = self;
            let url = format!("{}/tenants", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_tenants",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_tenant`]

    [`Client::create_tenant`]: super::Client::create_tenant*/
    #[derive(Debug, Clone)]
    pub struct CreateTenant<'a> {
        client: &'a super::Client,
        body: Result<types::builder::CreateTenantRequest, String>,
    }
    impl<'a> CreateTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateTenantRequest>,
            <V as std::convert::TryInto<types::CreateTenantRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateTenantRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateTenantRequest,
                ) -> types::builder::CreateTenantRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/tenants`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TenantResponse>, Error<types::ApiError>> {
            let Self { client, body } = self;
            let body = body
                .and_then(|v| types::CreateTenantRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!("{}/tenants", client.baseurl,);
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_tenant",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                400u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                409u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::get_tenant`]

    [`Client::get_tenant`]: super::Client::get_tenant*/
    #[derive(Debug, Clone)]
    pub struct GetTenant<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
    }
    impl<'a> GetTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/tenants/{tenant_id}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TenantResponse>, Error<types::ApiError>> {
            let Self { client, tenant_id } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "get_tenant",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::update_tenant`]

    [`Client::update_tenant`]: super::Client::update_tenant*/
    #[derive(Debug, Clone)]
    pub struct UpdateTenant<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
        body: Result<types::builder::UpdateTenantRequest, String>,
    }
    impl<'a> UpdateTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::UpdateTenantRequest>,
            <V as std::convert::TryInto<types::UpdateTenantRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `UpdateTenantRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::UpdateTenantRequest,
                ) -> types::builder::UpdateTenantRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `PUT` request to `/tenants/{tenant_id}`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::TenantResponse>, Error<types::ApiError>> {
            let Self {
                client,
                tenant_id,
                body,
            } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::UpdateTenantRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .put(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "update_tenant",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::delete_tenant`]

    [`Client::delete_tenant`]: super::Client::delete_tenant*/
    #[derive(Debug, Clone)]
    pub struct DeleteTenant<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
    }
    impl<'a> DeleteTenant<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        ///Sends a `DELETE` request to `/tenants/{tenant_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::ApiError>> {
            let Self { client, tenant_id } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_tenant",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                403u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_api_keys`]

    [`Client::list_api_keys`]: super::Client::list_api_keys*/
    #[derive(Debug, Clone)]
    pub struct ListApiKeys<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
    }
    impl<'a> ListApiKeys<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/tenants/{tenant_id}/api-keys`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListApiKeysResponse>, Error<types::ApiError>> {
            let Self { client, tenant_id } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}/api-keys",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_api_keys",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_api_key`]

    [`Client::create_api_key`]: super::Client::create_api_key*/
    #[derive(Debug, Clone)]
    pub struct CreateApiKey<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
        body: Result<types::builder::CreateApiKeyRequest, String>,
    }
    impl<'a> CreateApiKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateApiKeyRequest>,
            <V as std::convert::TryInto<types::CreateApiKeyRequest>>::Error: std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map(From::from)
                .map_err(|s| format!("conversion to `CreateApiKeyRequest` for body failed: {}", s));
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateApiKeyRequest,
                ) -> types::builder::CreateApiKeyRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/tenants/{tenant_id}/api-keys`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::CreateApiKeyResponse>, Error<types::ApiError>> {
            let Self {
                client,
                tenant_id,
                body,
            } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateApiKeyRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}/api-keys",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_api_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::revoke_api_key`]

    [`Client::revoke_api_key`]: super::Client::revoke_api_key*/
    #[derive(Debug, Clone)]
    pub struct RevokeApiKey<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
        key_id: Result<::std::string::String, String>,
    }
    impl<'a> RevokeApiKey<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
                key_id: Err("key_id was not initialized".to_string()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        pub fn key_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.key_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for key_id failed".to_string()
            });
            self
        }
        ///Sends a `DELETE` request to `/tenants/{tenant_id}/api-keys/{key_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::ApiError>> {
            let Self {
                client,
                tenant_id,
                key_id,
            } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let key_id = key_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}/api-keys/{}",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
                encode_path(&key_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "revoke_api_key",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::list_datasets`]

    [`Client::list_datasets`]: super::Client::list_datasets*/
    #[derive(Debug, Clone)]
    pub struct ListDatasets<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
    }
    impl<'a> ListDatasets<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        ///Sends a `GET` request to `/tenants/{tenant_id}/datasets`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::ListDatasetsResponse>, Error<types::ApiError>> {
            let Self { client, tenant_id } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}/datasets",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .get(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "list_datasets",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                200u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::create_dataset`]

    [`Client::create_dataset`]: super::Client::create_dataset*/
    #[derive(Debug, Clone)]
    pub struct CreateDataset<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
        body: Result<types::builder::CreateDatasetRequest, String>,
    }
    impl<'a> CreateDataset<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
                body: Ok(::std::default::Default::default()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        pub fn body<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<types::CreateDatasetRequest>,
            <V as std::convert::TryInto<types::CreateDatasetRequest>>::Error: std::fmt::Display,
        {
            self.body = value.try_into().map(From::from).map_err(|s| {
                format!(
                    "conversion to `CreateDatasetRequest` for body failed: {}",
                    s
                )
            });
            self
        }
        pub fn body_map<F>(mut self, f: F) -> Self
        where
            F: std::ops::FnOnce(
                    types::builder::CreateDatasetRequest,
                ) -> types::builder::CreateDatasetRequest,
        {
            self.body = self.body.map(f);
            self
        }
        ///Sends a `POST` request to `/tenants/{tenant_id}/datasets`
        pub async fn send(
            self,
        ) -> Result<ResponseValue<types::DatasetResponse>, Error<types::ApiError>> {
            let Self {
                client,
                tenant_id,
                body,
            } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let body = body
                .and_then(|v| types::CreateDatasetRequest::try_from(v).map_err(|e| e.to_string()))
                .map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}/datasets",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .post(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .json(&body)
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "create_dataset",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                201u16 => ResponseValue::from_response(response).await,
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
    /**Builder for [`Client::delete_dataset`]

    [`Client::delete_dataset`]: super::Client::delete_dataset*/
    #[derive(Debug, Clone)]
    pub struct DeleteDataset<'a> {
        client: &'a super::Client,
        tenant_id: Result<::std::string::String, String>,
        dataset_id: Result<::std::string::String, String>,
    }
    impl<'a> DeleteDataset<'a> {
        pub fn new(client: &'a super::Client) -> Self {
            Self {
                client: client,
                tenant_id: Err("tenant_id was not initialized".to_string()),
                dataset_id: Err("dataset_id was not initialized".to_string()),
            }
        }
        pub fn tenant_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.tenant_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for tenant_id failed".to_string()
            });
            self
        }
        pub fn dataset_id<V>(mut self, value: V) -> Self
        where
            V: std::convert::TryInto<::std::string::String>,
        {
            self.dataset_id = value.try_into().map_err(|_| {
                "conversion to `:: std :: string :: String` for dataset_id failed".to_string()
            });
            self
        }
        ///Sends a `DELETE` request to `/tenants/{tenant_id}/datasets/{dataset_id}`
        pub async fn send(self) -> Result<ResponseValue<()>, Error<types::ApiError>> {
            let Self {
                client,
                tenant_id,
                dataset_id,
            } = self;
            let tenant_id = tenant_id.map_err(Error::InvalidRequest)?;
            let dataset_id = dataset_id.map_err(Error::InvalidRequest)?;
            let url = format!(
                "{}/tenants/{}/datasets/{}",
                client.baseurl,
                encode_path(&tenant_id.to_string()),
                encode_path(&dataset_id.to_string()),
            );
            let mut header_map = ::reqwest::header::HeaderMap::with_capacity(1usize);
            header_map.append(
                ::reqwest::header::HeaderName::from_static("api-version"),
                ::reqwest::header::HeaderValue::from_static(super::Client::api_version()),
            );
            #[allow(unused_mut)]
            let mut request = client
                .client
                .delete(url)
                .header(
                    ::reqwest::header::ACCEPT,
                    ::reqwest::header::HeaderValue::from_static("application/json"),
                )
                .headers(header_map)
                .build()?;
            let info = OperationInfo {
                operation_id: "delete_dataset",
            };
            client.pre(&mut request, &info).await?;
            let result = client.exec(request, &info).await;
            client.post(&result, &info).await?;
            let response = result?;
            match response.status().as_u16() {
                204u16 => Ok(ResponseValue::empty(response)),
                404u16 => Err(Error::ErrorResponse(
                    ResponseValue::from_response(response).await?,
                )),
                _ => Err(Error::UnexpectedResponse(response)),
            }
        }
    }
}
/// Items consumers will typically use such as the Client.
pub mod prelude {
    pub use self::super::Client;
}
